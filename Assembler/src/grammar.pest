// Pest Grammar for Cicada-16 Assembly

// --- Silent Rules (ignored in the parse tree) ---

WHITESPACE = _{ " " | "\t" }

COMMENT = _{ ";" ~ (!NEWLINE ~ ANY)* }

// A line end is an optional comment followed by a required newline.
// It is silent as we don't need to see it in the final parse tree.
LINE_END = _{ (COMMENT)? ~ NEWLINE }

// --- Components ---

label = { identifier ~ ":" }

identifier = @{ ASCII_ALPHA ~ (ASCII_ALPHANUMERIC | "_")* }

// --- Operands ---

operand = { indirect | immediate_hex | immediate_dec | register | identifier }

indirect = @{ "(" ~ register ~ ")" }

register = @{ ("r" | "R") ~ ASCII_DIGIT }

immediate_hex = @{ ("0x" | "$") ~ ASCII_HEX_DIGIT+ }

immediate_dec = @{ ("-")? ~ ASCII_DIGIT+ }

// --- Condition Codes ---

cc = {
not_overflow
| not_negative
| not_carry
| not_zero
| overflow
| negative
| carry
| zero
}

overflow = @{ ^"V" }
not_overflow = @{ ^"NV" }
negative = @{ ^"N" }
not_negative = @{ ^"NN" }
carry = @{ ^"C" }
not_carry = @{ ^"NC" }
zero = @{ ^"Z" }
not_zero = @{ ^"NZ" }

jcc = ${ ^"j" ~ cc }
jrcc = ${ ^"jr" ~ cc }
callcc = ${ ^"call" ~ cc }

// --- Instructions ---

// The @ makes the rule "atomic", so it appears as a single token in the tree.
instruction = {
nop
| halt
| djnz
| ldi_2_op
| ld_2_op
| addi_2_op
| addi_1_op
| add_2_op
| add_1_op
| subi_2_op
| subi_1_op
| sub_2_op
| sub_1_op
| andi_2_op
| andi_1_op
| and_2_op
| and_1_op
| ori_2_op
| ori_1_op
| or_2_op
| or_1_op
| xori_2_op
| xori_1_op
| xor_2_op
| xor_1_op
| cmpi_2_op
| cmpi_1_op
| cmp_2_op
| cmp_1_op
| adci_2_op
| adc_2_op
| sbci_2_op
| sbc_2_op
| neg
| not
| swap
| jr_con
| jr
| jmp_con
| jmp
| call_con
| ccf
| scf
| rcf
// ... add all other instruction mnemonics here
}

nop = @{ ^"nop" }
halt = @{ ^"halt" }
djnz = { ^"djnz" ~ operand }
ld_2_op =  { ^"ld" ~ operand ~ "," ~ operand }
ldi_2_op =  { ^"ldi" ~ operand ~ "," ~ operand }
add_2_op = { ^"add" ~ operand ~ "," ~ operand }
add_1_op = { ^"add" ~ operand }
addi_2_op = { ^"addi" ~ operand ~ "," ~ operand }
addi_1_op = { ^"addi" ~ operand }
sub_2_op = { ^"sub" ~ operand ~ "," ~ operand }
sub_1_op = { ^"sub" ~ operand }
subi_2_op = { ^"subi" ~ operand ~ "," ~ operand }
subi_1_op = { ^"subi" ~ operand }
and_2_op = { ^"and" ~ operand ~ "," ~ operand }
and_1_op = { ^"and" ~ operand }
andi_2_op = { ^"andi" ~ operand ~ "," ~ operand }
andi_1_op = { ^"andi" ~ operand }
or_2_op = { ^"or" ~ operand ~ "," ~ operand }
or_1_op = { ^"or" ~ operand }
ori_2_op = { ^"ori" ~ operand ~ "," ~ operand }
ori_1_op = { ^"ori" ~ operand }
xor_2_op = { ^"xor" ~ operand ~ "," ~ operand }
xor_1_op = { ^"xor" ~ operand }
xori_2_op = { ^"xori" ~ operand ~ "," ~ operand }
xori_1_op = { ^"xori" ~ operand }
cmp_2_op = { ^"cmp" ~ operand ~ "," ~ operand }
cmp_1_op = { ^"cmp" ~ operand }
cmpi_2_op = { ^"cmpi" ~ operand ~ "," ~ operand }
cmpi_1_op = { ^"cmpi" ~ operand }
adc_2_op = { ^"adc" ~ operand ~ "," ~ operand }
adci_2_op = { ^"adci" ~ operand ~ "," ~ operand }
sbc_2_op = { ^"sbc" ~ operand ~ "," ~ operand }
sbci_2_op = { ^"sbci" ~ operand ~ "," ~ operand }
neg = @{ ^"neg" }
not = @{ ^"not" }
swap = @{ ^"swap" }
jmp = { ^"jmp" ~ operand }
jr_con = { jrcc ~ operand }
jr = { ^"jr" ~ operand }
jmp_con = { jcc ~ operand }
call_con = { callcc ~ operand}
ccf = @{ ^"ccf" }
scf = @{ ^"scf" }
rcf = @{ ^"rcf" }

// --- Core Rules ---

// This represents the actual content on a line, if any.
line_content = { (label | instruction) }

// A program is zero or more lines ending with a newline, followed by an
// optional final line that may not have a newline. This is a robust pattern
// that handles most source file conventions.
program = { SOI ~ (line_content? ~ LINE_END)* ~ EOI }
