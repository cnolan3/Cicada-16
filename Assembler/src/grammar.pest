// Pest Grammar for Cicada-16 Assembly

// --- Silent Rules (ignored in the parse tree) ---

WHITESPACE = _{ " " | "\t" }

COMMENT = _{ ";" ~ (!NEWLINE ~ ANY)* }

// A line end is an optional comment followed by a required newline.
// It is silent as we don't need to see it in the final parse tree.
LINE_END = _{ (COMMENT)? ~ NEWLINE }

// --- Components ---

label = { identifier ~ ":" }

identifier = @{ ASCII_ALPHA ~ (ASCII_ALPHANUMERIC | "_")* }

reg_prefix = _{ ^"r" }

reg_num = @{ ASCII_DIGIT }

hex_prefix = _{ "0x" | "$" }

hex_body = @{ ASCII_HEX_DIGIT+ }

open_paren = _{ "(" }

close_paren = _{ ")" }

// --- Operands ---

operand = {
predec
| postinc
| indirect
| absolute
| immediate_hex
| immediate_dec
| register
| identifier
| indexed
}

data_operand = {
immediate_hex
| immediate_dec
| identifier
}

indirect = ${ open_paren ~ register ~ close_paren }

absolute = ${ open_paren ~ immediate_hex ~ close_paren }

register = ${ reg_prefix ~ reg_num }

immediate_hex = ${ hex_prefix ~ hex_body }

immediate_dec = @{ ("-")? ~ ASCII_DIGIT+ }

indexed = { open_paren ~ register ~ "," ~ immediate_dec ~ close_paren }

predec = ${ "-(" ~ register ~ ")" }

postinc = ${ "(" ~ register ~ ")+" }

// --- Condition Codes ---

cc = {
not_overflow
| not_negative
| not_carry
| not_zero
| overflow
| negative
| carry
| zero
}

overflow = @{ ^"V" }
not_overflow = @{ ^"NV" }
negative = @{ ^"N" }
not_negative = @{ ^"NN" }
carry = @{ ^"C" }
not_carry = @{ ^"NC" }
zero = @{ ^"Z" }
not_zero = @{ ^"NZ" }

jcc = ${ ^"j" ~ cc }
jrcc = ${ ^"jr" ~ cc }
callcc = ${ ^"call" ~ cc }

// --- Instructions ---

// The @ makes the rule "atomic", so it appears as a single token in the tree.
instruction = {
nop
| halt
| djnz
| bit
| set
| res
| st_b
| st_2_op
| ldi_b
| ldi_2_op
| ld_b
| ld_2_op
| add_b
| add_sp
| addi_2_op
| addi_1_op
| add_2_op
| add_1_op
| sub_b
| subi_2_op
| subi_1_op
| sub_2_op
| sub_1_op
| and_b
| andi_2_op
| andi_1_op
| and_2_op
| and_1_op
| or_b
| ori_2_op
| ori_1_op
| or_2_op
| or_1_op
| xor_b
| xori_2_op
| xori_1_op
| xor_2_op
| xor_1_op
| cmp_b
| cmpi_2_op
| cmpi_1_op
| cmp_2_op
| cmp_1_op
| adci_2_op
| adci_1_op
| adc_2_op
| sbci_2_op
| sbci_1_op
| sbc_2_op
| push_f
| pop_f
| push_op
| pop_op
| neg
| not
| swap
| jr_con
| jr
| jmp_con
| jmp
| call_con
| call
| syscall
| ccf
| scf
| rcf
| enter
| leave
| reti
| ret
| ei
| di
| inc
| dec
| sra
| shl
| shr
| rol
| ror
| lea
// ... add all other instruction mnemonics here
}

nop = @{ ^"nop" }
halt = @{ ^"halt" }
djnz = { ^"djnz" ~ operand }
ld_2_op =  { ^"ld" ~ operand ~ "," ~ operand }
st_2_op =  { ^"st" ~ operand ~ "," ~ operand }
ldi_b = { ^"ldi.b" ~ operand ~ "," ~ operand }
ldi_2_op =  { ^"ldi" ~ operand ~ "," ~ operand }
add_2_op = { ^"add" ~ operand ~ "," ~ operand }
add_1_op = { ^"add" ~ operand }
add_b = { ^"add.b" ~ operand }
addi_2_op = { ^"addi" ~ operand ~ "," ~ operand }
addi_1_op = { ^"addi" ~ operand }
sub_2_op = { ^"sub" ~ operand ~ "," ~ operand }
sub_1_op = { ^"sub" ~ operand }
sub_b = { ^"sub.b" ~ operand }
subi_2_op = { ^"subi" ~ operand ~ "," ~ operand }
subi_1_op = { ^"subi" ~ operand }
and_2_op = { ^"and" ~ operand ~ "," ~ operand }
and_1_op = { ^"and" ~ operand }
and_b = { ^"and.b" ~ operand }
andi_2_op = { ^"andi" ~ operand ~ "," ~ operand }
andi_1_op = { ^"andi" ~ operand }
or_2_op = { ^"or" ~ operand ~ "," ~ operand }
or_1_op = { ^"or" ~ operand }
or_b = { ^"or.b" ~ operand }
ori_2_op = { ^"ori" ~ operand ~ "," ~ operand }
ori_1_op = { ^"ori" ~ operand }
xor_2_op = { ^"xor" ~ operand ~ "," ~ operand }
xor_1_op = { ^"xor" ~ operand }
xor_b = { ^"xor.b" ~ operand }
xori_2_op = { ^"xori" ~ operand ~ "," ~ operand }
xori_1_op = { ^"xori" ~ operand }
cmp_2_op = { ^"cmp" ~ operand ~ "," ~ operand }
cmp_1_op = { ^"cmp" ~ operand }
cmp_b = { ^"cmp.b" ~ operand }
cmpi_2_op = { ^"cmpi" ~ operand ~ "," ~ operand }
cmpi_1_op = { ^"cmpi" ~ operand }
adc_2_op = { ^"adc" ~ operand ~ "," ~ operand }
adci_2_op = { ^"adci" ~ operand ~ "," ~ operand }
adci_1_op = { ^"adci" ~ operand }
sbc_2_op = { ^"sbc" ~ operand ~ "," ~ operand }
sbci_2_op = { ^"sbci" ~ operand ~ "," ~ operand }
sbci_1_op = { ^"sbci" ~ operand }
push_f = { ^"push" ~ ^"f" }
pop_f = { ^"pop" ~ ^"f" }
push_op = { ^"push" ~ operand }
pop_op = { ^"pop" ~ operand }
neg = @{ ^"neg" }
not = @{ ^"not" }
swap = @{ ^"swap" }
jmp = { ^"jmp" ~ operand }
jr_con = { jrcc ~ operand }
jr = { ^"jr" ~ operand }
jmp_con = { jcc ~ operand }
call_con = { callcc ~ operand}
call = { ^"call" ~ operand }
syscall = { ^"syscall" ~ operand }
ccf = @{ ^"ccf" }
scf = @{ ^"scf" }
rcf = @{ ^"rcf" }
enter = @{ ^"enter" }
leave = @{ ^"leave" }
ret = @{ ^"ret" }
reti = @{ ^"reti" }
ei = @{ ^"ei" }
di = @{ ^"di" }
inc = { ^"inc" ~ operand }
dec = { ^"dec" ~ operand }
sra = { ^"sra" ~ operand }
shl = { ^"shl" ~ operand }
shr = { ^"shr" ~ operand }
rol = { ^"rol" ~ operand }
ror = { ^"ror" ~ operand }
add_sp = { ^"add" ~ ^"sp" ~ "," ~ operand }
bit = { ^"bit" ~ operand ~ "," ~ operand }
set = { ^"set" ~ operand ~ "," ~ operand }
res = { ^"res" ~ operand ~ "," ~ operand }
ld_b = { ^"ld.b" ~ operand ~ "," ~ operand }
st_b = { ^"st.b" ~ operand ~ "," ~ operand }
lea = { ^"lea" ~ operand ~ "," ~ operand }

// --- Directive Rules ---

data_operand_list = { data_operand ~ ("," ~ data_operand)* }

org_directive = { ^".org" ~ operand }

directive = { org_directive }

// --- Core Rules ---

// This represents the actual content on a line, if any.
line_content = { (label | instruction | directive) }

// A program is zero or more lines ending with a newline, followed by an
// optional final line that may not have a newline. This is a robust pattern
// that handles most source file conventions.
program = { SOI ~ (line_content? ~ LINE_END)* ~ EOI }
